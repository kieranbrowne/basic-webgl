<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
  <style>
  body { background: #000; margin: 0px; overflow: hidden; }
  </style>
</head>
<body>

  <canvas id="glCanvas" width="640" height="480"></canvas>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"></script>

  <script type="x-shader/x-vertex" id="vertexshader">

    // reads from javascript code
	attribute vec2 vertexPosition;
	attribute vec3 vertexColor;
    // set during this vertex shader for the frag step
    varying vec4 pos;
    varying vec4 color;
    // set in js loop
    uniform float uTime;

    void main() {
      gl_Position = vec4(vertexPosition.x-sin(uTime*1.0)/2.0,
                         vertexPosition.y-cos(uTime*1.0)/2.0,
                         0.0,1.0);
      gl_PointSize = 9.0;
      pos = gl_Position;
      color = vec4(vertexColor.r+abs(sin(uTime*1.0))*0.4,
                   vertexColor.g+abs(cos(uTime*1.0))*0.4,
                   vertexColor.b+abs(cos(uTime*1.4))*0.4,
                   1.0);
    }

  </script>

  <script type="x-shader/x-fragment" id="fragmentshader">

  #ifdef GL_ES
  precision highp float;
  #endif

  uniform float uTime;
  //uniform vec2 resolution;
  //uniform vec4 uColor;
  //varying vec4 color;
  //varying vec4 pos;
  //uniform float uTime;

  float sq(float x) {
    return x*x;
  }

  void main() {
      vec2 p = gl_FragCoord.xy / 400.0 * 0.7;
      vec3 col;
      for(float j = 0.0; j < 3.0; j++){
          for(float i = 1.0; i < 10.0; i++){
              p.x += 0.1 / (i + j) * sin(i * 10.0 * p.y + uTime + cos((uTime / (12. * i)) * i + j));
              p.y += 0.1 / (i + j)* cos(i * 10.0 * p.x + uTime + sin((uTime / (12. * i)) * i + j));
          }
          col[int(j)] = sin(75.0*sq(p.x)) + sin(75.0*sq(p.y));
      }
      gl_FragColor = vec4(col, 1.);
  }


  </script>
  <script>
    main();

    function main() {
      const canvas = document.querySelector("#glCanvas");
      // Initialize the GL context
      const gl = canvas.getContext("webgl",{ premultipliedAlpha: false });

      // Only continue if WebGL is available and working
      if (!gl) {
        alert("Unable to initialize WebGL. Your browser or machine may not support it.");
        return;
      }

      function createShader (gl, sourceCode, type) {
        // Compiles either a shader of type gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
        var shader = gl.createShader( type );
        gl.shaderSource( shader, sourceCode );
        gl.compileShader( shader );

        if ( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) {
          var info = gl.getShaderInfoLog( shader );
          throw 'Could not compile WebGL program. \n\n' + info;
        }
        return shader;
      }

      gl.clearColor(0.2, 0.2, 0.2, 0.4);
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      gl.enable(gl.DEPTH_TEST);

      const program = gl.createProgram();

      const vertShader = createShader(gl,document.getElementById('vertexshader').text, gl.VERTEX_SHADER);
      const fragShader = createShader(gl,document.getElementById('fragmentshader').text, gl.FRAGMENT_SHADER);
      gl.attachShader(program, vertShader);
      gl.attachShader(program, fragShader);


      gl.linkProgram(program);
      gl.useProgram(program);

      if ( !gl.getProgramParameter( program, gl.LINK_STATUS) ) {
        var info = gl.getProgramInfoLog(program);
        throw 'Could not compile WebGL program. \n\n' + info;
      }

      var aspect = canvas.width / canvas.height;

      var vertices = new Float32Array([
          // X, Y ,          R, G, B
          // Triangle 1
          0.0, 0.5, 1.0, 0.0, 0.0, // red
          0.5, -0.5,  0.0, 1.0, 0.0, // green
          -0.5,-0.5,  0.0, 0.0, 1.0, // blue
          // Triangle 2
          /*-0.5, 0.5, 1.0, 1.0, 0.0, // yellow
          0.4,-0.5,  1.0, 0.0, 1.0, // magenta
          -0.5,-0.5,  0.0, 1.0, 1.0 */// cyan
      ]);

      vbuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      itemSize = 5;
      numItems = vertices.length / itemSize;


      // Pass data to GPU

      program.vertexPosition = 
        gl.getAttribLocation(program, "vertexPosition");
      program.vertexColor = 
        gl.getAttribLocation(program, "vertexColor");

      gl.vertexAttribPointer(
          program.vertexPosition, // pointer to memory
          2,  // elements per attribute
          gl.FLOAT, // element type
          gl.FALSE,  // normalised?
          // size of individual element in memory
          5 * Float32Array.BYTES_PER_ELEMENT, 
          0 // offset from beginning of each vertex
          );
      gl.vertexAttribPointer(
          program.vertexColor, // pointer to memory
          3,  // elements per attribute
          gl.FLOAT, // element type
          gl.FALSE,  // normalised?
          // size of individual element in memory
          5 * Float32Array.BYTES_PER_ELEMENT, 
          // offset from beginning of each vertex
          2 * Float32Array.BYTES_PER_ELEMENT 
          );

      gl.enableVertexAttribArray(program.vertexPosition);
      gl.enableVertexAttribArray(program.vertexColor);


      program.uColor = gl.getUniformLocation(program, "uColor");
      gl.uniform4fv(program.uColor, [1.0, 0.3, 0.0, 1.0]);
      program.uTime = gl.getUniformLocation(program, "uTime");
      gl.uniform1f(program.uTime, Math.random());



      // Main draw loop

      const draw = (timestamp) => {
        // update time
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
        gl.uniform1f(program.uTime, timestamp/1000);
        // draw triangles
        gl.drawArrays(gl.TRIANGLES, 0, numItems);
        // loop
        window.requestAnimationFrame(draw);
      }
      window.requestAnimationFrame(draw);

    }

  </script>

  
</body>
</html>
